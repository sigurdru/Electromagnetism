
# Information about all exercises in the file part_in_box.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.part_in_box.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': ['To place the particles inside the box you can use\n'
                       '!bt\n'
                       '\\begin{verbatim}\n'
                       'import numpy as np\n'
                       'r = np.random.uniform(low, high, size)\n'
                       'v = np.random.uniform(loc, scale, size)\n'
                       '\\end{verbatim}\n'
                       '\n'
                       '!et'],
             'solution': '!bt\n'
                         '\\begin{verbatim}\n'
                         'class box:\n'
                         '    def __init__(self, N, L, q, m, eps0):\n'
                         '        """\n'
                         '        Set initial conditions\n'
                         '        """\n'
                         '        self.N = int(N)                     # num of '
                         'particles\n'
                         '        self.L = L                          # length '
                         'of side\n'
                         '        self.q = q                          # '
                         'charge\n'
                         '        self.eps0 = eps0                    # '
                         'permittivity of vacuum\n'
                         '        self.m = m                          # mass\n'
                         '        self.r = np.random.uniform(\n'
                         '            low=-L/2, high=L/2, size=(2, self.N)\n'
                         '        )                                   # '
                         'initial positions\n'
                         '        self.v = np.random.normal(\n'
                         '            loc=0, scale=10, size=(2, self.N)\n'
                         '        )                                   # '
                         'initial velocities\n'
                         '\\end{verbatim}\n'
                         '\n'
                         '!et',
             'text': 'Create a class \\texttt{box}, and a '
                     '\\texttt{\\_\\_init\\_\\_} function that takes the '
                     'amount of particles $N$, length of the side of the box '
                     '$L$, the charge of the particles $q$, mass of the '
                     'particles $m$ and vacuum permeability $\\epsilon_0$. You '
                     'also need to place the particles in the box, select '
                     'their positions randomly inside the box with velocities '
                     'selected from a normal distribution.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '!bt\n'
                         '\\begin{verbatim}\n'
                         'def force(self, r = None):\n'
                         '    """\n'
                         '    find electric force between particles\n'
                         '    """\n'
                         '    #testing if we gave r a value\n'
                         '    if r is None:\n'
                         '        r_test = self.r\n'
                         '    else:\n'
                         '        r_test = r\n'
                         '    #force array we are going to fill\n'
                         '    F = np.zeros((2, self.N))\n'
                         '    #possible to drop this for loop\n'
                         '    for i in range(self.N):\n'
                         '        #calculating the force between every '
                         'particle\n'
                         '        r_eval = r_test[:,i]\n'
                         '        ri = np.tile(r_eval, self.N-1)\n'
                         '        ri = np.reshape(ri, (self.N-1, 2)).T\n'
                         '        rm = np.delete(r_test, i, axis=1)\n'
                         '        r_mi = ri - rm\n'
                         '        F_mi = r_mi/np.linalg.norm(r_mi, axis=0)**2\n'
                         '        F[:, i] = np.sum(F_mi, axis=1)\n'
                         '    #need to add the natural constants\n'
                         '    F *= self.q**2/(4*np.pi*self.eps0)\n'
                         '    return F\n'
                         '\\end{verbatim}\n'
                         '\n'
                         '!et',
             'text': 'Now we want to create a function \\texttt{force} that '
                     'takes the current positions and returns the force on '
                     'each particle. We are only looking at electric forces so '
                     "it's sufficient to use Coulomb's law. It is possible to "
                     'vectorize the code such that there are no loops. The '
                     'solution shows a way to do it with one loop. NumPy '
                     'contains many directories that are useful to vectorize '
                     'code.'},
            {'answer': '',
             'file': None,
             'hints': ['To plot points instead of lines you can use '
                       '\\texttt{plt.scatter}.'],
             'solution': '!bt\n'
                         '\\begin{verbatim}\n'
                         'def plot_border(self):\n'
                         '    """\n'
                         '    plot the box border\n'
                         '    """\n'
                         '    plt.plot([-self.L/2, self.L/2],\n'
                         "             [-self.L/2, -self.L/2], 'k')  # bottom "
                         'side\n'
                         '    plt.plot([-self.L/2, self.L/2],\n'
                         "             [self.L/2, self.L/2], 'k')    # top "
                         'side\n'
                         '    plt.plot([-self.L/2, -self.L/2],\n'
                         "             [-self.L/2, self.L/2], 'k')   # left "
                         'side\n'
                         '    plt.plot([self.L/2, self.L/2],\n'
                         "             [-self.L/2, self.L/2], 'k',\n"
                         "             label = 'Walls')              # right "
                         'side\n'
                         'def plot_positions(self):\n'
                         '    """\n'
                         '    plot current positions as scatter-plot\n'
                         '    """\n'
                         "    plt.scatter(self.r[0,:], self.r[1,:], color='b', "
                         "label='Electrons')\n"
                         'def plot_arrows(self):\n'
                         '    """\n'
                         '    plot force arrows\n'
                         '    """\n'
                         '    F = self.force()\n'
                         '    plt.quiver(self.r[0,:], self.r[1,:], F[0, :], '
                         "F[1, :], color='r', label='Force')\n"
                         '\\end{verbatim}\n'
                         '\n'
                         '!et',
             'text': 'To make sure the forces makes sence it can be a good '
                     'idea visualize the forces. Make a vector plot using '
                     '\\texttt{quiver} from \\texttt{matplotlib.pyplot}. '
                     'Create a function \\texttt{plot\\_arrows} that plots the '
                     'force-arrows on each particle. In order to make the plot '
                     "easier to understand plot the particles' positions and "
                     'the borders of the box.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'Expanding on your previous '
                         '\\texttt{\\_\\_init\\_\\_} function it should look '
                         'something like this (changes are marked with '
                         '\\texttt{\\#!\\#}):\n'
                         '!bt\n'
                         '\\begin{verbatim}\n'
                         'def __init__(self, N, L, q, m, eps0, dt, T):\n'
                         '    """\n'
                         '    Set initial conditions\n'
                         '    """\n'
                         '    self.N = int(N)                     # num of '
                         'particles\n'
                         '    self.L = L                          # length of '
                         'side\n'
                         '    self.q = q                          # charge\n'
                         '    self.eps0 = eps0                    # '
                         'permittivity of vacuum\n'
                         '    self.m = m                          # mass\n'
                         '    self.T = T                          # time we '
                         'are looking at #!#\n'
                         '    self.dt = dt                        # time '
                         'step              #!#\n'
                         '    self.Nsteps = '
                         'int(T/dt)                                      #!#\n'
                         '    self.r = np.random.uniform(\n'
                         '        low=-L/2, high=L/2, size=(2, self.N)\n'
                         '    )                                   # initial '
                         'positions\n'
                         '    self.v = np.random.normal(\n'
                         '        loc=0, scale=10, size=(2, self.N)\n'
                         '    )\n'
                         '\\end{verbatim}\n'
                         '\n'
                         '!et',
             'text': 'Now we are ready to simulate the motion of the '
                     'particles. First expand your \\texttt{\\_\\_init\\_\\_} '
                     'to take a small time step $\\Delta t$ and the period $T$ '
                     'you want to evaluate. Also define the number of steps '
                     '$N_{steps}$ this will require.'},
            {'answer': '',
             'file': None,
             'hints': ['To find the particles hitting the walls you can use '
                       '\\texttt{np.where()}.'],
             'solution': 'The code can look something like this:\n'
                         '!bt\n'
                         '\\begin{verbatim}\n'
                         'def RHS(self, r0):\n'
                         '    """\n'
                         '    returns right hand side of the ode\n'
                         '    """\n'
                         '    #the array we will return\n'
                         '    drdt = np.zeros((2,2,self.N))\n'
                         '    #finding what particles are hitting the walls\n'
                         '    index = np.where(np.abs(r0[0, :])>self.L/2)\n'
                         '    #changing the sign of the velocity (elastic '
                         'collision)\n'
                         '    r0[1][index] *= -1\n'
                         '    #placing the particles outside the box inside '
                         'again\n'
                         '    np.where(r0[0, :] > self.L/2, r0[0, :], '
                         'self.L/2)\n'
                         '    np.where(r0[0, :] < -self.L/2, r0[0, :], '
                         '-self.L/2)\n'
                         '    #filling the array\n'
                         '    drdt[0, :, :] = r0[1, :]\n'
                         '    drdt[1, :, :] = self.force(r = r0[0, :])/self.m\n'
                         '    return drdt\n'
                         '\\end{verbatim}\n'
                         '\n'
                         '!et',
             'text': 'To find the motion of the particles it is good practice '
                     'to separate the function that solves the differential '
                     'equations from the numeric solver that solves for time. '
                     'To solve the differential equations we are simply going '
                     'to write a function \\texttt{RHS} that takes a vector '
                     '$r_0 = (r, v)$ containing positions and velocities and '
                     "returns the derivative of that vector $r' = (r', v') = "
                     '(v, a)$. You can assume elastic collision with the '
                     'walls.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '!bt\n'
                         '\\begin{verbatim}\n'
                         'def solver(self):\n'
                         '    """\n'
                         '    solves the motions of the particles with '
                         'Euler-Chromer\n'
                         '    """\n'
                         '    #the solution we will fill\n'
                         '    sol = np.zeros((self.Nsteps, 2, 2, self.N))\n'
                         '    #setting initial conditions\n'
                         '    sol[0, 0, :, :] = self.r[:, :]\n'
                         '    sol[0, 1, :, :] = self.v[:, :]\n'
                         '    for i in range(self.Nsteps-1):\n'
                         '        drdt = self.RHS(sol[i, :, :, :])\n'
                         '        sol[i+1, :, :] = drdt*dt + sol[i, :, :, :]\n'
                         '    #the time we evaluated\n'
                         '    t = np.linspace(0, self.T, self.Nsteps)\n'
                         '    return sol, t\n'
                         '\\end{verbatim}\n'
                         '\n'
                         '!et',
             'text': 'Choosing what solver we are going to use is important '
                     'and you should ponder a while on what you should '
                     'prioritize. If the simulation is going on for a while '
                     'should we prioritize energy-conservation? Write a '
                     'function \\texttt{solver} that solves and returns the '
                     'motion of the particles. The solution solves the motion '
                     "using Euler-Chromer's method, but you should try another "
                     'one and compare.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '!bt\n'
                         '\\begin{verbatim}\n'
                         '#animation\n'
                         'sol, t = system.solver()\n'
                         'Nsteps = len(t)\n'
                         '#Creating the figure we are going to use\n'
                         'fig = plt.figure()\n'
                         'ax = plt.axes(xlim=(-L/2+0*1*L, L/2+0*1*L), '
                         'ylim=(-L/2+0*1*L, L/2+0*1*L))\n'
                         '#the particles we are goint to plot\n'
                         "particles, = ax.plot([], [], 'bo', "
                         "label='Electrons')\n"
                         '#the walls\n'
                         'ax.plot([-L/2, L/2],\n'
                         "        [-L/2, -L/2], 'k')  # bottom side\n"
                         'ax.plot([-L/2, L/2],\n'
                         "        [L/2, L/2], 'k')    # top side\n"
                         'ax.plot([-L/2, -L/2],\n'
                         "        [-L/2, L/2], 'k')   # left side\n"
                         'ax.plot([L/2, L/2],\n'
                         "        [-L/2, L/2], 'k',\n"
                         "        label = 'Walls')   # right side\n"
                         'def init():\n'
                         '    """\n'
                         '    init function that clears axis\n'
                         '    """\n'
                         '    ax.clear\n'
                         '    return particles\n'
                         'speed = 1\n'
                         'def animate(i):\n'
                         '    """\n'
                         '    this function animates\n'
                         '    """\n'
                         "    ax.set_title('Tid =%fs' %(i*dt*speed))\n"
                         '    particles.set_data(sol[i*speed, 0, :, :])\n'
                         '    return particles\n'
                         '#plot\n'
                         'anim = animation.FuncAnimation(fig, animate, '
                         'init_func=init,\n'
                         '                               '
                         'frames=int(Nsteps/speed), interval=1, blit=False)\n'
                         "plt.suptitle('Animation of particles', fontsize=14)\n"
                         "ax.set_ylabel('Position y-axis [m]')\n"
                         "ax.set_xlabel('Position x-axis [m]')\n"
                         "plt.axis('equal')\n"
                         'plt.legend(loc=1)\n'
                         'plt.show()\n'
                         '\\end{verbatim}\n'
                         '\n'
                         '!et',
             'text': 'Finally animate the motion of the particles. To do this '
                     'you can use \\texttt{matplotlib.animate}.'}],
  'text': '*(Made by: Sigurd SÃ¸rlie Rustad)*\n'
          '\n'
          '\\noindent\n'
          'In this exercise we are going to simulate and animate particles in '
          'a box. We are going to do this in steps, so that the process '
          'becomes easier, but also to verify that our results makes sence. We '
          'will work with electrons inside a square box with sides $L$. '
          'Although we will be working in two dimensions, if you vectorize '
          'your code, expanding to 3D is quite straight forward.',
  'title': 'Particles in a box',
  'type': 'Exercise',
  'type_visible': True}]